

内存

三级地址映射

    linux-0.11中使用的三级地址映射，并同时使用了分段和分页机制。
    三级地址是虚拟地址，线性地址，物理地址。
    虚拟地址是程序使用的地址。线性地址是处理器用来寻址的地址。物理地址是数据在物理内存中实际的地址。
    虚拟地址经过分段机制之后就变成线性地址，线性地址经过分页机制之后就变成物理地址。

分段机制

    分段机制使用GDT表和LDT表首先。
    GDT（Global Descriptor Table）存放全局段的描述符。
    LDT（Local Descriptor Table）存放局部段的描述符。
    每一个段描述符由三个部分组成：段基址，段限长，段属性。
    虚拟地址加上段基址之后即是线性地址。虚拟地址必须在段限长的范围内，否则非法。段属性用来描述段的特征以及判断虚拟地址是否合法。

分页机制

    分页机制使用二级页表实现。
    32位CPU支持4GB线性地址空间，这4GB地址空间被划分为2^20个4KB的页。页表即是用来将线性地址空间中的页映射到物理地址空间的页上。
    因为使用4KB的页所以所有页的起始地址的低12位都是0，只需提供高20位即可完成映射，因此低12位可以用来存放一些属性信息。
    高20位被分为2段，其中高10位用于页目录表的索引，低10位用于页表的索引。
    下面简述页表寻址的流程。
    对于一个32位的线性地址，首先根据将最高10位作为索引在页目录表中寻找到到对应的页表的物理地址，然后根据中间10位作为索引找到对应页的物理地址，最后低12位作为业内偏移即可找到对应数据的物理地址。

需求加载与写时复制

    页目录表和页表的低12位因为不参与映射，因此可以用来存放一些属性信息，比如存在位和读写位。
    当存在位置位时，说明该页在物理内存中存在，可以直接使用，否则说明该页在磁盘缓存中，此时处理器会产生一个页面异常，然后页面异常中断处理程序调用缺页处理程序do_no_page，将需要的页面交换到内存中。这称为需求加载。
    内核在执行execve系统调用时，只是设置了相应的页表，并没有将程序真实复制到内存中，当程序运行产生缺页异常时，内核才会通过缺页异常处理程序将程序页面加载到内存中。
    
    当发生页面写保护时，可能是因为父进程与子进程共享页面，此时处理器也会产生一个页面异常，然后页面异常中断处理程序调用写保护处理程序do_wp_page，处理程序分配新的页面，然后重新执行程序。

    当内核执行fork系统调用时也没有真实复制父进程的代码和数据，而是在子进程的页表中指向父进程的数据，并且将相应页面设置为只读，这样当一个进程试图写入数据时就会产生写保护异常，此时内核才会真实的为进程分配物理内存分配页面。
    缺页异常与写保护异常共用一个系统中断号，成为页面异常。页面异常中断处理程序会根据CPU提供的信息调用具体的处理程序。

    当一个页面长期不使用时就可能被交换出物理内存，然后在使用时重新交换回物理内存中。这是虚拟内存的工作原理，虚拟内存可以使程序觉得使用了比物理内存大得多的内存。
